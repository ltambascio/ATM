HW6 Design:

Overview:
	The objective of this assignment was to incorporate multithreading to the
socket based ATM of homework assignment 4.  This would allow for potentially 
greater throughput and increased (faster) response time.  The design calls for 
a thread pool where individual threads are activated when a request arrives on 
the socket.  The server process creates a "work order" runnable object, places 
it on the request queue, and then notifies the thread pool objects that a new
request is waiting for them.  A thread pool object will then wake up, create a
new thread to process the transaction, and then return to waiting for the next
request to show up.

	Some logic had to be moved from the Server class to the ATMRunnable class 
since it will actually be processing the transaction, not the Server class.


Submission notes:
	The ATMProxyTest class was removed from this version of the application 
since it was not able to get reliable results since it was testing the server
which now handles things in threads which will yield inconsistent results.

	The build script now has a demo target which forks a thread or the server 
process.  You'll see the client side output in the ant output.  To see the 
server output, you'll need to start the server process up manually.  The 
classpath for both the server and the client processes should be 
"dist\lib\HW6.jar;lib\log4j-1.2.16.jar" if you're running it from the project 
root directory.  You will need to at least execute the "dest" target in order to
run the server and client.


Class:	cscie160.hw6.Account
	Since this class will be called from multiple threads simultaneously, the 
methods need to be synchronized.  Both the getBalance and setBalance methods 
have had the synchronized keyword added to their declarations.  No other changes
were needed for this class.


Class:	cscie160.hw6.Server
	This class needed many changes.  It's primary responsibility now is to 
service client requests and add them to the request queue.  To do that it will 
need to create a small pool of threads and a request "queue" as part of the 
constructor.

Method: serviceClient
	As the server reads requests, it will create an ATMRunnable object, add it 
to the request queue (vector), and notify the waiting ATMThread objects that 
there is a new request waiting to be processed.  It will process all the 
requests it can, and then wait for the next socket connection.  This will allow
the server to process the client more than one time without having to be 
restarted.  This was not intended to handle multiple clients simultaneously, but
was intended to allow the client process to be run multiple times against the 
one server process.  As written in homework 4, the server needs to be restarted
each time the client is run.

Method:	executeCommand
	This method has been removed from this class and the logic has been added 
to the run method of the ATMRunnable class.


Class:	cscie160.hw6.ATMRunnable
	This class is designed to run each transaction in it's own thread.  It has
references to the command line to execute, the remote ATM reference, and the
print stream for the response to the client.

Method:	run
	This method essentially does what the old executeCommand method in the 
Server class did, and it is largely based on it.  The executeCommand method 
return a Float object, took the command line string as a parameter, and declared
ATMException as thrown.  The command line string is passed to the AMTRunnable 
object when it is created, but the run method can neither return a value to the 
caller nor throw an ATMException.  It will use the passed in print stream to 
return the balance value for that command to the caller, and it now handles the
exceptions itself.


Class:	cscie160.hw6.ATMThread
	This class is the thread pool class.  It is given a reference to the 
requests object that it will monitor.

Method:	Constructor
	The constructor receives a reference to the requests queue/object (it is 
actually a Vector<ATMRunnable>).

Method:	run
	This method loops infinitely to continuously process requests.  Once it has 
processed one request, it will loop around and wait on the requests object 
again.  When it is notified there is a request object to process, it tries to 
get the request object off of the queue.  The assumption is that it will get and
remove the first element in the vector.  Once it has the request object, which
itself implements Runnable, a new Thread is created with the request object, and 
it is started.  After that, it will loop around to wait again for the next 
request.


--------------------------------------------------------------------------------
HW4 Design:

Overview:
	The objective of this assignment was to create a simple ATM back end
implementation that has simply one account.  The goal was to start using basic
network calls and to write JUnit test cases along with an Ant script that 
built everything.

Class:	cscie160.hw4.Account
	This class is a simple bean with one property, balance.  It has a get and 
set method for balance, as well as a customized toString method.


Class:	cscie160.hw4.ATMImplementation
	This class implements the ATM interface on the server side.  It has one 
account it manages at this point in time to perform operations upon (e.g. 
deposit, withdraw).

Method:	Constructor
	This method initializes the account class that all the other methods will
operate on.

Method:	deposit
	An amount to deposit is passed to this method.  It gets the account's 
current balance, adds the deposited amount to that balance, and then updates the
balance to the new amount.

Method: withdraw
	A withdrawal amount is passed to this method.  It gets the account's 
current balance, deducts the passed in amount, and then updates the balance to
the new amount.

Method:	getBalance
	This method simply returns the current balance of the account.


Class:	cscie160.hw4.Server
	This class needed a minor change from what was distributed to use the 
ATMImplementation class I developed.  The constructor for this class now uses
the actual ATMImplementation class instead of the anonymous no-op implementation
of the ATM interface.


Class:	AccountTest
	This class has two test methods that test getting the balance and setting 
the balance.

Method:	testGetBalance
	This method first validates that it initially gets the correct initial 
balance of zero.  The balance is then updated to a different known value, and
then we validate that getBalance returns that known value.

Method:	testSetBalance
	This method sets the balance to a known value, and then uses getBalance to
validate that it was set correctly.


Class:	cscie160.hw4.ATMImplementationTest
	This test class validates the deposit and withdraw functions while using the
get balance function in the process.

Method:	setUp
	This method creates the instance of the ATMImplementation class that will be
tested.

Method:	testDeposit
	This method makes two deposits to the account and validates the balance 
after each one.  After the second deposit, the balance should be the sum of 
both deposits.

Method:	testWithdraw
	This method first deposits $600, and validates that the balance only has the
$600 deposited.  It then makes two withdrawals ensuring the correct balance 
remains after each one.


Class:	cscie160.hw4.ATMProxyTest
	This test class requires that the server process be running because it calls
the actual ATMProxy class that expects to make calls across the network to 
perform it's operations.  Since we need to use one instance of the ATM proxy 
class across all the test methods, we need to make it static.  Since the tests
will be done against a static instance, this breaks the independence of each
test method.  They are expected to be run in a particular order that was 
observed.

Method:	setUp
	This method has uses @BeforeClass annotation so that it is only called once
to initialize the ATMProxy instance, which is defined as a static member.  It 
initializes the proxy to call the server instance on the localhost on port 7777.

Method:	testDeposit
	This method makes a single initial deposit, which is validated using the 
getBalance method.  It is expected to be called first.

Method:	testWithraw
	This method makes a single withdrawal from the account, validating the 
balance afterward.  It is expected to be the second method.

Method:	testGetBalance
	This method first validates the current balance left over from the two 
previous test methods, and it then makes one deposit and one withdrawal, 
validating the balance after each operation.


Build file:
	The build.xml file has five targets (clean, init, compile, dist, and test).
The test source files, while in the same packages as the main source files, have
a different directory.  The clean target deletes the build, dist, and apidocs
directories.  The init target creates the build directory.  The compile target 
compiles both the main source and test source directories and then it creates 
Javadocs for the main classes.  The dist target creates a jar file for the 
classes compiled.  The test target runs the test classes.  It does this by 
spawning off a forked process for the server, and then runs all the classes in 
a batch.


Submission Notes:
	To demonstrate the ant build script, only the source code, the JUnit jar 
file, the build.xml file, and this overview are included in the zipped 
submission.  From the main directory run "ant test" to execute the full build 
script, including running the JUnit tests.  To run the server and client from
the command line, the classpath of ".\dist\lib\HW4.jar" (for Windows) should be 
included with the java command.  To run the JUnit tests from the command line,
add the junit-4.1.jar in the lib directory to the classpath.